---
title: "Dates and times with tsibbles and lubridate"
output: html_document
---

[tsibble demo](https://tsibble.tidyverts.org/)

## Tsibbles

Take a look at these daily records of a household's electricity usage. 

```{r}
library(tidyverse)
library(lubridate)
library(tsibble)
energy <- here::here("data", "daily_consumption.csv") %>% 
  read_csv()
energy
```

Let's make this a `tsibble` in the same way we'd convert a data frame to a `tibble`, with one minor difference: we need to specify which column holds the time variable. This is the _index_.

```{r}
(energy <- as_tsibble(energy, index = date))
```

We already see an improvement in the sorted dates!

This is an example of _time series_ data, because the time interval has a regular spacing. A `tsibble` cleverly determines and stores this interval. With the energy consumption data, the interval is one day:

```{r}
interval(energy)
```

But notice that there is no record for December 21, 2006, in what would be Row 5. Such records are called _implicit NA's_, and if you don't draw these out explicitly, you could mess up your analysis if it's anticipating your data to be equally spaced in time. Just `full_gaps()` to bring them out of hiding:


```{r}
(energy <- fill_gaps(energy))
```

Better to plot the data now that these gaps are filled in. Let's check out 2010. See how the plot without NA's can be a little misleading? Always be as honest as possible with your data.

```{r}
small_energy <- filter(energy, year(date) == 2010)
cowplot::plot_grid(
  ggplot(small_energy, aes(date, intensity)) +
    geom_line() +
    theme_bw() +
    xlab("date (2010)") +
    ggtitle("NA's made explicit"),
  ggplot(drop_na(small_energy), aes(date, intensity)) +
    geom_line() +
    theme_bw() +
    xlab("date (2010)") +
    ggtitle("NA's in hiding (implicit)"),
  nrow = 2
)
```


## Dates

Extract time keys out of dates using handy functions from `lubridate`, and new friends from the `tsibble` package. Here's a demo of some of these functions:

```{r}
(energy_many <- energy %>% 
  mutate(
    weekday     = lubridate::wday(date, label = TRUE),
    day         = lubridate::day(date),
    month       = lubridate::month(date),
    year        = lubridate::year(date),
    day_of_year = lubridate::yday(date),
    year_month  = tsibble::yearmonth(date),
    year_week   = tsibble::yearweek(date)
  ))
```


Is there a weekly pattern in voltage? How about across the year?

```{r}
cowplot::plot_grid(
  ggplot(energy_many, aes(weekday, intensity)) +
    geom_jitter(alpha = 0.25) +
    geom_boxplot(alpha = 0.25) +
    theme_bw(),
  ggplot(energy_many, aes(day_of_year, intensity)) +
    geom_line(aes(group = year), alpha = 0.25) +
    theme_bw()
)
```

There's seasonality across the year. Let's get a mean estimate on each day of the year. But, since we're grouping by chunks of time, we use `index_by()` instead of `group_by()`. This is so that the `tsibble` can be re-indexed by the grouping variable.

```{r}
energy %>% 
  index_by(day_of_year = yday(date)) %>% 
  summarise_all(mean, na.rm = TRUE)
```

What if we wanted to make the time series less granular? Instead of total daily consumption, how about total weekly consumption?

```{r}
energy %>% 
  index_by(yearweek = yearweek(date)) %>% 
  summarise_all(sum)
```

By the way, there's no need to worry about "truncated weeks" at the beginning and end of the year. For example, December 31, 2019 is a Tuesday, and is Week 53, but its "yearmonth" is Week 1 in 2020:

```{r}
dec31 <- "2019-12-31"
wday(dec31, label = TRUE)
week(dec31)
yearweek(dec31)
```



